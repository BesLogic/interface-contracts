Voici ce qu'il y a à faire dans l'exercice sur les interfaces et la notion
de contrats.

1. (Ensemble) Implémentez un système de tri de données par date de création,
   d'abord en y allant avec la façon la plus simple, puis en utilisant des
   contrats pour réduire la quantité de code nécessaire pour appliquer la
   même logique sur plusieurs types.

2. (Facile) Créez une interface pour le OrderingService qui va éviter aux
   contrôleurs de dépendre d'une implémentation concrète et l'aider à ne pas
   dépendre de méthodes dont il n'a pas besoin, dans le futur. Typez les
   variables de type OrderingService selon l'interface extraite.

3. (Facile) Créez un nouveau OrderingService, qui triera, celui-ci, par date
   de modification.
   Assurez-vous qu'il implémente la même interface que le serice original,
   et allez l'ajouter dans les contrôleurs appropriés afin de gérer le cas
   où l'on veut trier par date de modification.
   C'est une forme de stratégie un peu simplifiée, où le comportement du
   IOrderingService varie pendant l'exécution du programme.

4. (Facile) Créez une nouvelle interface (un nouveau contrat) INameable qui
   permettra de traiter les Orders et les Users de la même façon dans un
   NameOrderingService.
   Créez ensuite un NameOrderingService, et complétez l'implémentation des
   tris offerts par l'application dans les contrôleurs Users et Orders.
   Il s'agit des mêmes étapes que 1 et 3. Fiez-vous sur ce que vous y avez
   fait pour réussir cet objectif!

5. (Facile) Ouvrez la classe MegaService.
   Remarquez à quel point la classe propose toutes sortes de méthodes, qui
   jouent pourtant différents rôles dans l'application.
   Ceci viole les principes de responabilité unique et de ségrégation
   des interfaces. La classe fait beaucoup trop de choses différentes,
   et ses utilisateurs sont pris avec plusieurs méthodes dont ils n'ont pas
   besoin.
   Créez d'abord autant d'interfaces que nécessaire pour bien séparer les
   différentes responsabilités de cette classe. Assurez-vous que ces
   responsabilités sont le minimum nécessaire pour accomplir un ensemble de
   tâches.
   Découpez ensuite cette classe en plus petites classes, responsables
   d'implémenter une ou plusieurs des interfaces extraites précédemment.
   Ce genre de travail est ce que l'on appelle du refactoring : améliorer la
   qualité du code sans changer son fonctionnement.
   Ce genre d'opération ne devrait pas créer de bogues, et tous les tests
   unitaires associés devraient toujours passer après le refactoring (même
   s'il n'y en a présentement pas pour cet exercice).
   Vous devriez avoir au moins trois classes et quatre interfaces.

6. (Intermédiaire) Réduisez les services de tri à un seul service, à nouveau,
   qui prendra une stratégie en paramètre pour déterminer sur quel élément de
   l'objet appliquer son tri.
   C'est le même principe que l'exercice précédent, sauf que cette fois,
   on évite de créer un service par type de tri, alors pourtant que chaque
   service ne change qu'une petite partie de sa logique.
   Cet objectif est de niveau intermédiaire, puisqu'il faut utiliser des
   types génériques pour définir les méthodes nécessaires.
   La stratégie passée en paramètre, au nom de votre choix, contiendra une
   seule méthode, TKey GetOrderable<TSource, TKey>(TSource source).
   Adaptez le code existant afin d'utiliser ce nouveau paramètre.

7. (Avancé) Dans le code, lorsque nous avons une dépendance envers un service
   quelconque, nous créons une instance de ce service directement dans la
   méthode qui en a besoin (par exemple, les Repository créés dans les
   contrôleurs).
   Implémentez un petit système d'injection de dépendance, qui permettra aux
   méthodes de s'injecter leurs dépendances depuis un registre, plutôt que
   de créer des instances hors de contrôle des tests.
   Votre injecteur n'aura besoin que de deux méthodes : GetInstance<TInstance>
   et Register<TInterface, TClass>. Elles devront être statiques pour bien
   fonctionner.
   Enregistrez toutes les dépendances de l'application dans le fichier
   Global.asax, dans la méthode Application_Start.
   Remplacez ensuite les constructions de classes par un appel à cet injecteur.
   Ignorez pour l'instant le cas des Repository, puisqu'ils font l'objet du
   prochain objectif.

8. (Avancé) En ce moment, les données de l'application ne changent pas (elles
   ne proviennent pas d'une base de données). Dans le futur, ce serait
   intéressant d'obtenir les données depuis une base de données, sans avoir à
   tout réécrire le code de Repository.
   Créez une interface générique qui permettra de définir un contrat global,
   peu importe le type utilisé. Assurez-vous que votre interface étende
   l'interface IEnumerable<T>, pour éviter d'avoir à la spécifier dans chaque
   classe.
   Enregistrez chaque classe concrète auprès de votre injecteur de dépendance
   afin que les clients puissent obtenir leur Repository auprès de votre
   injecteur plutôt que de les construire eux-mêmes.
   Bien que cela ne fasse pas partie des notions vues aujourd'hui, créez une
   classe abstraite MockRepository qui se chargera d'implémenter les détails
   de IEnumerable, et créez une propriété abstraite qui devra fournir une liste
   de données de type générique, afin de réduire au maximum le code nécessaire
   pour les classes héritant de ce type de Repository.

9. (Pour les téméraires) Maintenant que vous avez des Repository abstraits en
   interfaces, créez des tests unitaires pour le OrderingService créé aux
   étapes précédents.
   Créez des mocks pour les Repository, afin de vous assurer que les services
   de tri arrivent bien à exécuter leur travail selon la stratégie fournie,
   indépendemment des données fournies.
   Par exemple, fournissez un ensemble de données vide, un ensemble de données
   contenant un seul élément, et des ensembles de données contenant des données
   nulles.
   À priori, créez des mocks manuellement, en implémentant les interfaces à
   même la classe de tests.
   Si vous vous sentez d'attaque, utilisez la bibliothèque Moq pour générer
   ces mocks.
